<style type="text/css">

div.fieldContainer {
	width: 240px;
	height: 480px;
	position:absolute;
	background-color: #000000;
	left: 130px;
	top: 0px;
}

div#playfield {
	width: 240px;
	height: 480px;
	margin-top: 0px;
	background-color: transparent;
	margin-left: auto;
	margin-right: auto;
	border-style: solid;
	border-width: 1px;
	border-top-width:0px;
	border-color: #AAAAAA;
	padding: 0px;
	position:absolute;
	top:0px;
	z-index: 3;
}
div#shadowfield {
	width: 240px;
	height: 480px;
	background-color: transparent;
	margin-top: 0px;
	margin-left: auto;
	margin-right: auto;
	border-style: solid;
	border-width: 1px;
	border-top-width:0px;
	border-color: #AAAAAA;
	padding: 0px;
	position:relative;
	top: 0px;
	z-index: 1;
	display:block;
	opacity: .35;
}
div#otherPlayersDiv {
	width:330px;
	position:absolute;
	left:100px;
	top:100px;
}
div.otherPlayersField {
	width: 121px;
	height: 240px;
	margin: 20px;
	
	background-color: black;
	border-style: solid;
	border-width: 1px;
	border-top-width:0px;
	border-color: #AAAAAA;
	padding: 0px;
	z-index: 5;
}

div.toprow {
	display:none;
}

label {
	font-family:sans-serif;
	font-size:8pt;
	padding:0px;
	margin:0px;
}

div.nextPieceContainer {
	width: 82px;
	height: 0%;
	background-color: transparent;
	position: absolute;
	right: 25px;
	bottom: 10px;
}

div.nextPiece {
	width: 80px;
	height: 40px;
	background-color: transparent;
	position: absolute;
	margin: 0px auto;
}

div#nextPiece0 {
	border: 0px #AAAAAA solid;
}






div.pfring {
	width: 500px;
	height: 480px;
	background-color: #000000;
	margin: 0px auto;
	margin-top: 5px;
	border-style: solid;
	border-width: 0px;
	border-color: #444444;
	padding: 0px;
	position:relative;
}

div.explain {
	position: relative;
	margin-left: auto;
	margin-right: auto;
	font-face: Verdana, Arial, sans-serif;
	font-size: 10pt; 
}

body {
	background-color: #AAAAAA;
	text-align: center;
}

span { 
	position: relative;
	margin: 1px;
	padding: 0px;
	height: 10px;
	width: 10px;
	float: left;
	background-color: transparent;
	border: transparent outset 4px;
}

span.otherPlayer {
	position: relative;
	margin: 0px;
	margin-bottom: 1px;
	margin-left: 1px;
	padding: 0px;
	height: 5px;
	width: 5px;
	float: left;
	background-color: transparent;
	border: transparent outset 2px;
}

span.square1 {
}

input.piecesCount {
	margin-top:25px;
	width:238px;
	top:66px;
}

</style>
<script language="javascript" type="text/javascript">

// Key codes
var DIR_KEY_DOWN = 40;
var DIR_KEY_UP = 38;
var DIR_KEY_LEFT = 37;
var DIR_KEY_RIGHT = 39;

var SPACE_KEY = 32;
// Used for immediate reaction to keypress
function setKeyReaction(keyEventHandler) {
	document.onkeydown = function(e) {
		if (window.event) // IE
		{
			keyEventHandler(window.event.keyCode);
		}
		else if (e.which) // Netscape/Firefox/Opera
		{
			keyEventHandler(e.which);
		}
	};
}

// Used for delayed reaction to keypresses, just store keycode
var currentKeyPress = null;
function setKeyMemory() {
	document.onkeydown = function(e) {
		if (window.event) // IE
		{
			currentKeyPress = window.event.keyCode;
		}
		else if (e.which) // Netscape/Firefox/Opera
		{
			currentKeyPress = e.which;
		}
	};
	document.onkeyup = function(e) {
		currentKeyPress = null;
	};
}

		setKeyReaction(function(keyCode) {
			switch (keyCode) {
			case DIR_KEY_DOWN:
				down();
				break;
			case DIR_KEY_UP:
				clockwise();
				break;
			case DIR_KEY_LEFT:
				left();
				break;
			case DIR_KEY_RIGHT:
				right();
				break;
			case SPACE_KEY:
				drop();
				break;
			}
		});
		
// ***********************
//  Preloading Tetris
//  square pictures. 
// ***********************
/*
s0= new Image(20,20); 
s0.src="/blickles/p/0.png";
s1= new Image(20,20); 
s1.src="/blickles/p/1.png";
s2= new Image(20,20); 
s2.src="/blickles/p/2.png";
s3= new Image(20,20); 
s3.src="/blickles/p/3.png";
s4= new Image(20,20); 
s4.src="/blickles/p/4.png";
s5= new Image(20,20); 
s5.src="/blickles/p/5.png";
s6= new Image(20,20); 
s6.src="/blickles/p/6.png";
s7= new Image(20,20); 
s7.src="/blickles/p/7.png";
s8= new Image(20,20); 
s8.src="/blickles/p/8.png";
*/
// ***********************
// 		 Variables. 
// ***********************

// Real playing field. Note that this representation is actually upside-down. 
/*
var Field = [
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 1
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 2
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 3
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 4
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 5
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 6
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 7
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 8
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 9
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	10
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	11
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	12
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	13
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	14
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	15
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	16
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	17
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	18
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	19
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	20
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	21
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	22
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	23
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	24
	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]	//	25
]; */

// Test playing field.

 var Field = [					
//	  1  2  3  4  5  6  7  8  9 10 11 12
	[10,10,10,10,10,10,10,10,10,10,10, 0], 	//	 1
 	[10,10,10,10,10,10,10,10,10,10,10, 0], 	//	 2
 	[10,10,10,10,10,10,10,10,10,10,10, 0], 	//	 3
 	[10,10,10,10,10,10,10,10,10,10,10, 0], 	//	 4
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 5
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 6
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 7
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 8
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	 9
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	10
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	11
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	12
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	13
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	14
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	15
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	16
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	17
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	18
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	19
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	20
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	21
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	22
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	23
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	24
 	[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 	//	25
 ];								


var BOARD_WIDTH = Field[0].length
var BOARD_HEIGHT = Field.length
var SQUARE_COUNT = 5
var PREVIEW_PIECE_COUNT = 4

/*
	Rotational reference matrices for X and Y coordinates.
	
	These are the instructions for the pieces in the
		current rotation. So for a piece in its fourth
		rotational position (e.g., global variable r
		is 3), we look up its rotational instructions
		in RotateX[t][3] and RotateY[t][3] - these
		tell the rotational position r = 3 how to
		rotate into its next position (i.e., r = 0).
	First dimension: Tetromino. Because of this,
		RotateX[0] and RotateY[0] are both null, as
		there is no tetromino associated with the
		number 0. 
	Second dimension: Unique rotational position. The
		global variable r is used as the index for
		this matrix. 
	Third dimension: Square. The final square is
		usually a copy of the 4th square, and  shares
		all of its coordinates and rotational
		instructions. This doesn't apply to the 3
		piece and the 5 piece, which have the
		penultimate and final squares sharing
		coordinates  and rotational instructions and
		no pieces sharing these things, respectively.
*/

RotateX =[null,
	[						//	3
		[ 1, 0, 0, 0, 0],
		[ 0,-1, 1, 1, 1],
		[-1, 0, 0, 0, 0],
		[ 0, 1,-1,-1,-1]
	],
	[						//	I
		[ 0,-1, 1, 2, 2],		//		Rotational position 1/2
		[ 0, 1,-1,-2,-2]		//		Rotational position 2/2
	],
	[						//	L
		[ 0, 1,-1, 0, 0],
		[ 0, 1,-1,-2,-2],
		[ 0,-1, 1, 0, 0],
		[ 0,-1, 1, 2, 2]
	],
	[						//	J
		[ 0,-1, 1, 2, 2],
		[ 0,-1, 1, 0, 0],
		[ 0, 1,-1,-2,-2],
		[ 0, 1,-1, 0, 0]
	],
	[						//	S
		[ 0,-1, 1, 2, 2],
		[ 0, 1,-1,-2,-2]
	],
	[						//	Z
		[ 0, 1,-1,-2,-2],
		[ 0,-1, 1, 2, 2]
	],
	[						//	T
		[ 0, 1,-1,-1,-1],
		[ 0, 1,-1, 1, 1],
		[ 0,-1, 1, 1, 1],
		[ 0,-1, 1,-1,-1]
	],
	[						// O has no rotations. 
		[ 0, 0, 0, 0, 0],
		[ 0, 0, 0, 0, 0]
	],
	[						//	5
		[ 0, 1,-1, 0,-2],
		[ 0, 1,-1, 2, 0],
		[ 0,-1, 1, 0, 2],
		[ 0,-1, 1,-2, 0]
	]
];

RotateY = [0,
	[						//	3
		[ 0,-1, 1, 1, 1],
		[-1, 0, 0, 0, 0],
		[ 0, 1,-1,-1,-1],
		[ 1, 0, 0, 0, 0]
	],
	[						//	I
		[ 0, 1,-1,-2,-2],		//		Rotational position 1/2
		[ 0,-1, 1, 2, 2]		//		Rotational position 2/2
	],
	[						//	L
		[ 0, 1,-1,-2,-2],		//		Rotational position 1/4
		[ 0,-1, 1,-0,-0],		//		etc.
		[ 0,-1, 1, 2, 2],
		[ 0, 1,-1,-0,-0]
	],
	[						//	J
		[ 0,-1, 1,-0,-0],
		[ 0, 1,-1,-2,-2],
		[ 0, 1,-1,-0,-0],
		[ 0,-1, 1, 2, 2]
	],
	[						//	S
		[ 0, 1, 1,-0,-0],
		[ 0,-1,-1,-0,-0]
	],
	[						//	Z
		[ 0, 1, 1,-0,-0],
		[ 0,-1,-1,-0,-0]
	],
	[						//	T
		[ 0, 1,-1, 1, 1],
		[ 0,-1, 1, 1, 1],
		[ 0,-1, 1,-1,-1],
		[ 0, 1,-1,-1,-1]
	],
	[					// O has no rotations. 
		[ 0,-0,-0,-0,-0],
		[ 0,-0,-0,-0,-0]
	],
	[						//	5
		[ 0, 1,-1, 2, 0],
		[ 0,-1, 1, 0, 2],
		[ 0,-1, 1,-2, 0],
		[ 0, 1,-1, 0,-2]
	]
];


// Matrices used for drawing
// the initial pieces. 
// PieceShapeMatrix hierarchy: 
//   First dimension: Tetromino
//   Second dimension: Square

var NewX = [0,
	[ 5, 6, 5, 5, 5], // 3
	[ 6, 7, 5, 4, 4], // I 
	[ 5, 4, 6, 6, 6], // L
	[ 5, 6, 4, 4, 4], // J
	[ 5, 6, 5, 4, 4], // S
	[ 5, 4, 5, 6, 6], // Z
	[ 5, 4, 6, 5, 5], // T
	[ 5, 6, 5, 6, 6], // O
	[ 6, 5, 7, 5, 7]  // 5
];

var NewY = [0,
	[23,23,22,22,22], // 3
	[23,23,23,23,23], // I
	[22,22,22,23,23], // L
	[22,22,22,23,23], // J
	[23,23,22,22,22], // S
	[23,23,22,22,22], // Z
	[23,23,23,22,22], // T
	[23,23,22,22,22], // O
	[23,23,23,22,22]  // 5
];

// Tetromino index establisher. 

var t=0;
var r=0;
var gameOn=false;

// ***********************
// 		 Objects. 
// ***********************


function Square() {
	this.x = 6;
	this.y = 23;
	this.oldx = 6;
	this.oldy = 23;
	this.r = 0;
	this.shy = 0;
	this.soldy = 1;
	this.shx = 6;
	this.soldx = 6;
}

Squares = [
	new Square(),
	new Square(),
	new Square(),
	new Square(),
	new Square()
];

// ***********************
// 		 Functions. 
// ***********************

function drawpiece() {

//	The process works like this:
//		1. Erase all pieces on the board. 
//		2. Draw the current piece.
//		3. Draw the current piece's shadow. 

	// 1. 
	for (s=0; s<SQUARE_COUNT; s++) {
			ysidstr = (Squares[s].shy<10) ? "0"+Squares[s].shy : Squares[s].shy;							// Y Shadow ID String
			xsidstr = (Squares[s].shx<10) ? "0"+Squares[s].shx : Squares[s].shx;							// X Shadow ID String
			document.getElementById('s'+ysidstr+''+xsidstr).style.borderColor = 'transparent';
			document.getElementById('s'+ysidstr+''+xsidstr).style.backgroundColor = 'transparent';
			yidstr = (Squares[s].oldy<10) ? "0"+Squares[s].oldy : Squares[s].oldy;
			xidstr = (Squares[s].oldx<10) ? "0"+Squares[s].oldx : Squares[s].oldx;
			document.getElementById(yidstr+''+xidstr).style.borderColor = 'transparent';
			document.getElementById(yidstr+''+xidstr).style.backgroundColor = 'transparent';
	} 
	dropby = dropbyf();
	
	// 2. 
	col = color_lookup(t)
	for (s=0; s<SQUARE_COUNT; s++) {
		yidstr = (Squares[s].y<10) ? "0"+Squares[s].y : Squares[s].y;
		xidstr = (Squares[s].x<10) ? "0"+Squares[s].x : Squares[s].x;
			document.getElementById(yidstr+''+xidstr).style.borderColor = col;
			document.getElementById(yidstr+''+xidstr).style.backgroundColor = col;
	}
	// 3. 
	for (s=0; s<SQUARE_COUNT; s++) {
		Squares[s].shx = Squares[s].x;
		Squares[s].shy = Squares[s].y - dropby; 
		ysidstr = (Squares[s].shy<10) ? "0"+Squares[s].shy : Squares[s].shy;
		xsidstr = (Squares[s].shx<10) ? "0"+Squares[s].shx : Squares[s].shx;
			document.getElementById('s'+ysidstr+''+xsidstr).style.borderColor = col;
			document.getElementById('s'+ysidstr+''+xsidstr).style.backgroundColor = col;
	}


}

function color_lookup(t) {
	switch (t) {
		case 0:
			return 'transparent';
		case 1:
			return '#FF00FF';
		case 2:
			return '#FF0000';
		case 3:
			return '#00FF88';
		case 4:
			return '#FFFF00';
		case 5:
			return '#FFA000';
		case 6:
			return '#AA00FF';
		case 7:
			return '#3333FF';
		case 8:
			return '#00FFFF';
		case 9:
			return '#AAFF00';
		case 10:
			return '#CCCCCC';
	}
}

function clockwise() {
	if (isLegalRotation(0)) {
		for (s=0; s<SQUARE_COUNT; s++) {
			Squares[s].oldx = Squares[s].x;
			Squares[s].oldy = Squares[s].y;
			Squares[s].x += RotateX[t][r][s];
			Squares[s].y += RotateY[t][r][s];
		}
		drawpiece();
		hasNotMoved=false;
		r = (r+1) % (RotateX[t].length);
	}
}

function counterclockwise() {
	if (isLegalRotation(1)) {
		for (i=0; i<SQUARE_COUNT; i++) {
			Squares[s].oldx = Squares[s].x;
			Squares[s].oldy = Squares[s].y;
			Squares[s].x += 0-(RotateX[t][(r-1+RotateY[t].length) % (RotateX[t].length)][i-1]);
			Squares[s].y += 0-(RotateY[t][(r-1+RotateY[t].length) % (RotateY[t].length)][i-1]);
		}
		hasNotMoved=false;
		r = (r-1+RotateY[t].length) % (RotateX[t].length);
		drawpiece();
	}
}

function right() {
	if (isLegalMove(1)) {
		for (s=0; s<SQUARE_COUNT; s++) {
			Squares[s].oldx = Squares[s].x;
			Squares[s].x+=1;
			Squares[s].oldy = Squares[s].y;
		}
		hasNotMoved=false;
		drawpiece();
	}
}

function left() {
	if (isLegalMove(2)) {
		for (s=0; s<SQUARE_COUNT; s++) {
			Squares[s].oldx = Squares[s].x;
			Squares[s].x-=1;
			Squares[s].oldy = Squares[s].y;
		}
		hasNotMoved=false;
		drawpiece();
	}
}

function down() {
	clearInterval(downint);
	downint = setInterval("down()", SPEED);	
	if (isLegalMove(0)) {
		for (s=0; s<SQUARE_COUNT; s++) {
			Squares[s].oldy = Squares[s].y;
			Squares[s].y-=1;
			Squares[s].oldx = Squares[s].x;
		}
		hasNotMoved=false;
		drawpiece();
	}
	else {
		drop();
	}
}

function drop() {

	dropby = dropbyf();

	for (s=0; s<SQUARE_COUNT; s++) {
		Squares[s].oldx = Squares[s].x;
		Squares[s].oldy = Squares[s].y;
		Squares[s].y -= dropby;
		Field[Squares[s].y][Squares[s].x] = t;
	}
	if (dropby>0) {
		hasNotMoved=false;
	}
	drawpiece();
	register.reportBoard()
	clearFullLines();
	setupNew();

}

function dropbyf() {
	d = Math.min(Squares[0].y,Squares[1].y,Squares[2].y,Squares[3].y,Squares[4].y);	//	Largest Possible Drop
	
	for (s=0; s<SQUARE_COUNT; s++) {										//	For all squares,
		for (j=Squares[s].y; j>=0; j--) {									// 	between their current height and the ground,
			if (Field[j][Squares[s].x]>0) {									//	if there's a square there,
				d = Math.min(d, Squares[s].y-j-1);							//	then if that's smaller than the currently-planned drop, change plans.
				break;														//	and, since all lower squares won't be applicable, break. 
			}
		}
	}
	return d;
}

function isLegalRotation(rot) {
	// 
	//	Rotation reference:
	//		0 - clockwise
	//		1 - counter-clockwise
	//

	switch (rot) {
		case 0:
			for (s=0; s<SQUARE_COUNT; s++) {
				if (
					Field[
						Squares[s].y+RotateY[t][r][s] /*
							whatever the current square's y is
							add to that:
								
				*/	]
					==undefined 
					
					|| 
					
					Field[
						Squares[s].y+RotateY[t][r][s]][Squares[s].x+RotateX[t][r][s]]
					==undefined
					
					||
					
					Field[
						Squares[s].y+RotateY[t][r][s]][Squares[s].x+RotateX[t][r][s]
					]
					>0
					
					) {
					return false;
				}
			}
			break;
		case 1:
			for (s=0; s<SQUARE_COUNT; s++) {
				if (
					Field[
						Squares[s].y-RotateY[t][(r-1+RotateY[t].length) % (RotateY[t].length)][s]
					]
					==undefined
					
					||
					
					Field[
						Squares[s].y-RotateY[t][(r-1+RotateY[t].length) % (RotateY[t].length)][s]
					][
						Squares[s].x-RotateX[t][(r-1+RotateY[t].length) % (RotateX[t].length)][s]
					]
					==undefined
					
					||
					
					Field[
						Squares[s].y-RotateY[t][(r-1+RotateY[t].length) % (RotateY[t].length)][s]
					][
						Squares[s].x-RotateX[t][(r-1+RotateY[t].length) % (RotateX[t].length)][s]
					]
					>0	
					
					) {
					return false;
				}
			} 
			break;
	}
	return true;
}


function isLegalMove(dir) {
	//
	//	Move reference: 
	//		0 - down
	//		1 - right
	//		2 - left
	//
	switch (dir) {
		case 0:
			for (s=0; s<SQUARE_COUNT; s++) {
				if (Field[Squares[s].y-1]==undefined || Field[Squares[s].y-1][Squares[s].x]>0) {
					return false;
				}
			}
			break;
		case 1:
			for (s=0; s<SQUARE_COUNT; s++) {
				if (Field[Squares[s].y][Squares[s].x+1]==undefined || Field[Squares[s].y][Squares[s].x+1]>0) {
					return false;
				}
			}
			break;
		case 2:
			for (s=0; s<SQUARE_COUNT; s++) {
				if (Field[Squares[s].y][Squares[s].x-1]==undefined || Field[Squares[s].y][Squares[s].x-1]>0) {
					return false;
				}
			}
			break;
	}
	return true;
}

var SPEED = 1000;

function clearFullLines() {
	clearInterval(downint);
	downint = setInterval("down()", SPEED);
	linesWereCleared = false;
	// Only check to see if the lines your most recently landed piece could have affected are full; no need to re-check the whole board
	for (i=Math.max(Squares[0].y,Squares[1].y,Squares[2].y,Squares[3].y,Squares[4].y); i>=Math.min(Squares[0].y,Squares[1].y,Squares[2].y,Squares[3].y,Squares[4].y); i--) { 
		lineFull = true;
		for (j=0; j<BOARD_WIDTH; j++) {
			if (Field[i][j]==0) {
				lineFull = false;
				break;
			}
		}
		if (lineFull) {
			linesWereCleared = true;
			for (j=i; j<BOARD_HEIGHT-1; j++) {
				for (k=0; k<BOARD_WIDTH; k++) {
	 				Field[j][k] = Field[j+1][k];
	 			}
			}
			for (j=0; j<BOARD_WIDTH; j++) {
				Field[BOARD_HEIGHT-1][j]=0;
			}
			document.getElementById('linesCount').value=parseFloat(document.getElementById('linesCount').value)+1;
		}
	}
	if (linesWereCleared) {
		refreshField(Math.min(Squares[0].y,Squares[1].y,Squares[2].y,Squares[3].y,Squares[4].y));
	}
}

function refreshField(startrow) {
	for (e=startrow; e<BOARD_HEIGHT; e++) {
		yidstr = (e<10) ? '0'+e : ''+e;
		for (f=0; f<BOARD_WIDTH; f++) {
			xidstr = (f<10) ? '0'+f : ''+f;
			document.getElementById(yidstr+''+xidstr).style.borderColor = color_lookup(Field[e][f]);
			document.getElementById(yidstr+''+xidstr).style.backgroundColor = color_lookup(Field[e][f]);
			document.getElementById(yidstr+''+xidstr).className += " square1"
		}
	}
}

function starter() {
	if (!gameOn) {
		hasNotMoved=false;
		document.getElementById('linesCount').value=0;
		refreshField(0);
		gameOn = true;
		register.sendInfo("request","startGame")
		setupNew();
		downint = setInterval("down()", SPEED);
	}
}

function gameOver() {
	gameOn=false;
	clearInterval(downint);
	document.getElementById('starter').value="Restart";
	alert("Game over.");
	clearField();
}

function clearField() {
	clearInterval(downint);
	for (i=0; i<BOARD_HEIGHT+1; i++) {
		for (j=0; j<BOARD_WIDTH; j++) {
			Field[i][j] = 0;
			istr = (i<10) ? '0'+i : ''+i;
			jstr = (j<10) ? '0'+j : ''+j;
			document.getElementById(istr+''+jstr).style.backgroundImage = 'none';
		}
	}
}
piecesArray = [];

register = new Object;
register.pullPieces 	=	function() {
								this.sendInfo("request","sendPieces")
							}
register.reportBoard	=	function() {
								this.sendInfo("board",Field)
							}
register.sendInfo		=	function(label,data) {
								s = {
									"label"	:	label,
									"data"	:	data
								}
								this.ws.send(JSON.stringify(s))
							}

register.ws = registerPlayer();

function newPlayer(id) {
	if (document.getElementById(id) == null) {
		buf = ""
		buf += "<div class='otherPlayersField' id='"+id+"'>"
		for (i=BOARD_HEIGHT-1; i>=0; i--) {
			buf += "\t<div class=\""
			if (i==BOARD_HEIGHT-1) {
				buf += "top"
			}
			buf += "row\">\n"
			for (j=0; j<BOARD_WIDTH; j++) {
				buf += "\t\t<span class=\"otherPlayer\" id=\""+id+TwoDigits(i)+TwoDigits(j)+"\"></span>\n"
			}
			buf += "\t</div>\n"
		} 
		document.getElementById('otherPlayersDiv').innerHTML += buf
	}
}

function removePlayer(id) {
	var child = document.getElementById(id);
	var parent = document.getElementById('otherPlayersDiv');
	parent.removeChild(child);
}

function registerPlayer() {
	if ("WebSocket" in window) {
		var ws = new WebSocket("ws://localhost:8081/register");
		ws.onopen = function(evt) {
			document.getElementById('bd').style.backgroundColor = "#FFFF00";
			setTimeout("document.getElementById('bd').style.backgroundColor = '#AAAAAA'",1000)
			register.pullPieces();
		}
		ws.onmessage = function(evt) {
			incoming = JSON.parse(evt.data)
			d = incoming["data"]
			switch (incoming["label"]) {
				case "pieces":
					for (i=0; i<d.length; i++) {
						d[i] = 9 - (d[i] % 9);
					}
					piecesArray = d.concat(piecesArray);
					break;
				case "board":
					incoming = JSON.parse(evt.data);
					pkg = incoming["data"];
					if (document.getElementById(pkg["player"]) == null) {
						newPlayer(pkg["player"])
					}
					d = pkg["board"];
					for (i = 0; i < d.length; i++) {
					yidstr = (i<10) ? "0"+i : i;
						for (j = 0; j < d[i].length; j++) {
							xidstr = (j<10) ? "0"+j : j;
							document.getElementById(pkg["player"]+''+yidstr+''+xidstr).style.borderColor = color_lookup(d[i][j]);
							document.getElementById(pkg["player"]+''+yidstr+''+xidstr).style.backgroundColor = color_lookup(d[i][j]);
						}
					}					
					break;
				case "request":
					switch (incoming["data"]) {
						case "startGame":
							starter();
					}
					break;
				case "lines":
					addLines(d);
					break;
				case "newPlayer":
					newPlayer(d);
					break;
				case "removePlayer":
					removePlayer(d);
					break;
			}
			
		}
		ws.onclose = function(evt){
			document.getElementById('bd').style.backgroundColor = "#FF0000";
			setTimeout("document.getElementById('bd').style.backgroundColor = '#AAAAAA'",1000)
		}
	}
	return ws
}

function addLines(d) {
	for (i = BOARD_HEIGHT-1; i >= d; i-- ) {
		for (j = 0; j < BOARD_WIDTH; j++) {
			Field[i][j] = Field[i-d][j];
		}
	}
	emptyColumn = Math.floor(Math.random()*BOARD_WIDTH)
	for (i = 0; i < d; i++ ) {
		for (j = 0; j < BOARD_WIDTH; j++) {
			Field[i][j] = 10;
		}
		Field[i][emptyColumn] = 0
	}
	register.reportBoard();
	refreshField(0);
	drawpiece();
}

function setupNew() {
	if (hasNotMoved) {
		gameOver();
		return 0;
	}
	else {
		t = getNew();
		r = 0;
		hasNotMoved=true;
		for (s=0; s<SQUARE_COUNT; s++) {
			Squares[s].x = NewX[t][s];
			Squares[s].y = NewY[t][s];
			Squares[s].oldx = Squares[s].x;
			Squares[s].oldy = Squares[s].y;
		}
		drawpiece();
	}

}

function getNew() {
	next = piecesArray.pop();
	if (piecesArray.length < 15) {
		register.pullPieces();
	}
	preview_piece_update();
	return next;
}

function preview_piece_update() {
	for (i=0; i<PREVIEW_PIECE_COUNT; i++) {
		for (j=0; j<2; j++) {
			for (k=0; k<4; k++) {
				document.getElementById('nP'+i+j+k).style.borderColor = 'transparent';
				document.getElementById('nP'+i+j+k).style.backgroundColor = 'transparent';
			}
		}
	}
	for (i=0; i<PREVIEW_PIECE_COUNT; i++) {
		col = color_lookup(piecesArray[piecesArray.length-i-1]);
		for (s=0; s<SQUARE_COUNT; s++) {
			document.getElementById('nP'+i+(NewY[piecesArray[piecesArray.length-i-1]][s]-22)+(NewX[piecesArray[piecesArray.length-i-1]][s]-4)).style.borderColor = col; 
			document.getElementById('nP'+i+(NewY[piecesArray[piecesArray.length-i-1]][s]-22)+(NewX[piecesArray[piecesArray.length-i-1]][s]-4)).style.backgroundColor = col; 
		}
	}
}












</script><body id='bd'>
<input type="button" id="starter" onclick="starter();" value="Start">
<div class="explain"> Left, right, up for CW turn, space for fast drop. <br><a href="todo.html">The To-Do List</a></div>
<input type="text" id="linesCount" class="linesCount">
<div class="pfring">
<div class="fieldContainer">
	<div id="shadowfield">
	<script language="javascript"> 
		function TwoDigits(n) {
			if (n<10) {
				return "0"+""+n
			} else {
				return n
			}
		}
		for (i=BOARD_HEIGHT-1; i>=0; i--) {
			document.write("\t<div class=\"")
			if (i==BOARD_HEIGHT-1) {
				document.write("top")
			}
			document.write("row\">\n")
			for (j=0; j<BOARD_WIDTH; j++) {
				document.write("\t\t<span id=\"s"+TwoDigits(i)+TwoDigits(j)+"\"></span>\n")
			}
			document.write("\t</div>\n")
		} 
	</script>
	</div>
	<div id="playfield">
	<script language="javascript"> 
		for (i=24; i>=0; i--) {
			document.write("\t<div class=\"")
			if (i==24) {
				document.write("top")
			}
			document.write("row\">\n")
			for (j=0; j<=11; j++) {
				document.write("\t\t<span id=\""+TwoDigits(i)+TwoDigits(j)+"\"></span>\n")
			}
			document.write("\t</div>\n")
		} 
	</script>
	</div>
</div>

<div class="nextPieceContainer">
	<script language="javascript">
		for (i=PREVIEW_PIECE_COUNT-1; i>=0; i--) {
			document.write("\t<div class='nextPiece' id='nextPiece"+i+"' style='bottom:"+(50+(i*50))+";opacity:"+(1-(i*.25))+"'>\n");
			for (j=1; j>=0; j--) {
				for (k=0; k<4; k++) {
					document.write("\t\t<span id='nP"+i+j+k+"'></span>\n");
				}
			}
			document.write("\t</div>\n");
		}
	</script>
</div>
	

</div>

<div id="otherPlayersDiv">
</div>
</body>

